<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>🔥ホモレッド</title>
  <style>
    * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --bg-primary: linear-gradient(145deg, #2100b57d, #e4e4e4);
    --bg-secondary: rgba(255, 255, 255, 0.9);
    --text-primary: #1d1d1f;
    --text-secondary: #007AFF;
    --particle-color: rgb(255 0 107);
    --glass-bg: rgb(255 255 255 / 22%);
    --glass-border: rgba(0, 0, 0, 0.06);
    --control-bg: rgb(0 0 0 / 10%);
    --control-hover: rgb(255 255 255 / 10%);
    --shadow-light: rgba(0, 0, 0, 0.08);
    --shadow-medium: rgba(0, 0, 0, 0.15);
}



body {
    background: var(--bg-primary);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, system-ui, sans-serif;
    overflow-x: hidden;
    position: relative;
    padding: 20px;
    transition: background 0.3s ease;
    /* Prevent Safari navigation gestures */
    overscroll-behavior-x: none;
    -webkit-overscroll-behavior-x: none;
    touch-action: pan-y pinch-zoom;
    -webkit-touch-action: pan-y pinch-zoom;
}

.bg-particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}

.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: var(--particle-color);
    border-radius: 50%;
    animation: float 8s infinite linear;
    opacity: 0.5;
}

@keyframes float {
    0% {
        transform: translateY(100vh) rotate(0deg) scale(0.5);
        opacity: 0;
    }

    5% {
        opacity: 0.8;
        transform: translateY(95vh) rotate(18deg) scale(0.7);
    }

    15% {
        opacity: 1;
        transform: translateY(85vh) rotate(54deg) scale(1);
    }

    85% {
        opacity: 1;
        transform: translateY(15vh) rotate(306deg) scale(1.2);
    }

    95% {
        opacity: 0.3;
        transform: translateY(5vh) rotate(342deg) scale(0.8);
    }

    100% {
        transform: translateY(-5vh) rotate(360deg) scale(0.3);
        opacity: 0;
    }
}

.main-container {
    position: relative;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 24px;
    width: 100%;
    max-width: 1200px;
}

.roulette-mega-container {
    position: relative;
    width: clamp(280px, 75vw, 460px);
    height: clamp(280px, 75vw, 460px);
    perspective: 800px;
    filter: drop-shadow(0 8px 32px rgb(255 255 255 / 15%));
    touch-action: pan-y;
}

.roulette-area {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
}

.roulette-wheel {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    position: absolute;
    background: conic-gradient(#007AFF 0% 5.56%, #34C759 5.56% 11.11%, #007AFF 11.11% 16.67%, #34C759 16.67% 22.22%, #007AFF 22.22% 27.78%, #34C759 27.78% 33.33%, #007AFF 33.33% 38.89%, #34C759 38.89% 44.44%, #007AFF 44.44% 50%, #34C759 50% 55.56%, #007AFF 55.56% 61.11%, #34C759 61.11% 66.67%, #007AFF 66.67% 72.22%, #34C759 72.22% 77.78%, #007AFF 77.78% 83.33%, #34C759 83.33% 88.89%, #007AFF 88.89% 94.44%, #FF9500 94.44% 100%);
  box-shadow:
    inset 2px 5px 2px rgb(255 255 255 / 13%),
    inset 0 0 1px rgb(255 255 255),
    inset 0 1px 1px rgb(255 255 255 / 65%),
    0 12px 48px rgba(0,0,0,0.08),
    0 1px 88px rgb(237 171 234 / 20%),

    0 0 23px #00000036,
    inset 0 0 23px #00000026;
    transform: perspective(800px) rotateX(8deg) rotateZ(0deg);
    transition: none;
    will-change: transform;
}

.number-label {
    position: absolute;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.number-text {
    position: absolute;
    left: 50%;
    top: 50%;
    font-size: clamp(18px, 3.5vw, 24px);
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    user-select: none;
    transform: translate(-50%, -50%);
    letter-spacing: 0.5px;
    transition: all 0.2s ease;
}

.number-text.last-result {
    animation: lastResultBlink 1.5s infinite;
    z-index: 10;
}

@keyframes lastResultBlink {
    0%, 100% {
        box-shadow: 0 0 0 0 rgba(0, 122, 255, 0);
        background: transparent;
    }

    50% {
        box-shadow: 0 0 12px 3px rgb(0 0 0 / 40%);
        background: rgba(0, 122, 255, 0.1);
        border-radius: 50%;
    }
}

.glass-display {
    position: absolute;
    bottom: -70px;
    left: 50%;
    transform: translateX(-50%) scale(1.2);
    width: 160px;
    height: 160px;
    border-radius: 50%;
    background: radial-gradient(ellipse at 40% 30%, rgb(255 255 255 / 20%) 0%, rgb(255 255 255 / 5%) 50%, #ffffff00 100%), radial-gradient(circle at center, rgba(0, 122, 255, 0.1) 0%, rgb(255 255 255 / 5%) 100%);
    backdrop-filter: blur(20px) saturate(1.2);
    border: 1px solid rgba(255, 255, 255, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
      box-shadow:
    inset 2px -2px 1px rgb(255 255 255 / 1%),
    inset 1px -1px 2px rgb(255 255 255 / 70%),
    inset -1px 1px 1px rgb(255 255 255 / 50%);
    animation: glassFloat 4s infinite ease-in-out;
}

@keyframes glassFloat {
    0% {
        transform: translateX(-50%) scale(1.2) translateY(0px) rotateX(0deg);
    }

    25% {
        transform: translateX(-50%) scale(1.22) translateY(-6px) rotateX(2deg);
    }

    50% {
        transform: translateX(-50%) scale(1.25) translateY(-12px) rotateX(0deg);
    }

    75% {
        transform: translateX(-50%) scale(1.22) translateY(-6px) rotateX(-2deg);
    }

    100% {
        transform: translateX(-50%) scale(1.2) translateY(0px) rotateX(0deg);
    }
}

.result-number {
    font-size: 3.5em;
    font-weight: 100;
    background: linear-gradient(180deg, #200060, #ff00ed, #ff0074);
    -webkit-background-clip: text;
    -webkit-text-fill-color: #ffffff00;
    background-clip: text;
    text-shadow: 0 2px 8px rgb(255 255 255 / 30%);
    user-select: none;
    cursor: pointer;
    transition: all 0.3s ease;
    animation: pulse 3s infinite;
}

@keyframes pulse {
    0% {
        transform: scale(1) rotateY(0deg);
        filter: brightness(1);
    }

    25% {
        transform: scale(1.02) rotateY(2deg);
        filter: brightness(1.1);
    }

    50% {
        transform: scale(1.08) rotateY(0deg);
        filter: brightness(1.2);
    }

    75% {
        transform: scale(1.02) rotateY(-2deg);
        filter: brightness(1.1);
    }

    100% {
        transform: scale(1) rotateY(0deg);
        filter: brightness(1);
    }
}

.result-number.blur {
    filter: blur(15px) brightness(0.8);
    opacity: 0.4;
}

.ball {
    position: absolute;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ffffff 20%, #007AFF 40%, #a6cbaf 80%);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
    z-index: 999 !important;
    transition: left 0.1s ease, top 0.1s ease;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    animation: ballGlow 2s infinite alternate;
    pointer-events: none;
}

@keyframes ballGlow {
    0% {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
        transform: scale(1) rotateZ(0deg);
    }

    50% {
        box-shadow: 0 8px 20px rgba(0, 122, 255, 0.4), 0 4px 8px rgba(52, 199, 89, 0.2);
        transform: scale(1.1) rotateZ(180deg);
    }

    100% {
        box-shadow: 0 6px 16px rgba(255, 149, 0, 0.3), 0 3px 6px rgba(0, 0, 0, 0.15);
        transform: scale(1) rotateZ(360deg);
    }
}

.controls-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    background: var(--glass-bg);
    backdrop-filter: blur(20px) saturate(1.2);
    border-radius: 44px;
    padding: 28px;
       box-shadow:
    inset 2px -2px 1px rgb(255 255 255 / 1%),
    inset 0 0 2px rgb(255 255 255),
    inset -2px 1px 13px rgb(255 255 255),
    inset 0 3px 8px rgb(0 0 0 / 30%);
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    transform: translateY(0);
    opacity: 1;
}

.controls-panel.slide-down {
    transform: translateY(80px);
    opacity: 0;
    pointer-events: none;
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.controls-panel.slide-up {
    transform: translateY(0);
    opacity: 1;
    pointer-events: auto;
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.controls-panel.fade-in {
    animation: fadeInSlideUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes fadeInSlideUp {
    0% {
        transform: translateY(60px) scale(0.95) rotateX(10deg);
        opacity: 0;
        filter: blur(5px);
    }

    30% {
        transform: translateY(20px) scale(0.98) rotateX(5deg);
        opacity: 0.7;
        filter: blur(2px);
    }

    60% {
        transform: translateY(-5px) scale(1.02) rotateX(-2deg);
        opacity: 0.9;
        filter: blur(0px);
    }

    80% {
        transform: translateY(2px) scale(1.01) rotateX(1deg);
        opacity: 1;
    }

    100% {
        transform: translateY(0) scale(1) rotateX(0deg);
        opacity: 1;
        filter: blur(0px);
    }
}

.chip-selector {
    display: flex;
    gap: 16px;
    margin-bottom: 20px;
    align-items: center;
}

.chip-selector-label {
    color: var(--text-primary);
    font-size: 17px;
    font-weight: 600;
    margin-right: 12px;
}

.chip-3d {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    font-weight: 700;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);

    border: 1px solid rgba(0, 0, 0, 0.04);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.chip-100 {
    background: linear-gradient(145deg, #007AFF, #00b7ff);
}

.chip-500 {
    background: linear-gradient(145deg, #FF3B30, #ff6bbf);
}

.chip-1000 {
    background: linear-gradient(145deg, #ff9000, #FFCC02);
}

.chip-3d:hover {
    transform: translateY(-4px) scale(1.05);
    filter: brightness(1.1);
    animation: chipHoverPulse 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) infinite alternate;
}

.chip-3d.selected {
    transform: translateY(-6px) scale(1.1);
    animation: chipSelected 2s infinite;
    filter: brightness(1.2);
}

@keyframes chipSelected {
    0% {
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2), 0 0 16px rgb(0 122 255);
        transform: translateY(-6px) scale(1.1) ;
    }

    25% {
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 25px rgb(0 255 64);
        transform: translateY(-8px) scale(1.12) ;
    }

    50% {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25), 0 0 20px rgb(255 149 0);
        transform: translateY(-6px) scale(1.1);
    }

    75% {
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 25px rgb(255 0 233 / 50%);
        transform: translateY(-8px) scale(1.12) ;
    }

    100% {
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2), 0 0 16px rgb(58 0 255);
        transform: translateY(-6px) scale(1.1) 
    }
}

.chip-3d::before {
    content: '';
    position: absolute;
    top: 5%;
    left: 25%;
    width: 44%;
    height: 15%;
    background: rgb(255 255 255 / 71%);
    border-radius: 50%;
    filter: blur(4px);
    pointer-events: none;
}

.chip-3d::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: linear-gradient(to bottom, #ffffff00 80%, rgba(0, 0, 0, 0.1) 100%);
    border-radius: 50%;
    pointer-events: none;
}

.mode-selector {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
}

.mode-btn {
    padding: 12px 20px;
    background: #cdcdcd96;
    color: var(--text-secondary);
    border-radius: 30px;
    cursor: pointer;
    transition: all 0.25s ease;
    font-weight: 600;
    font-size: 15px;
      box-shadow:
    inset -1px -1px 1px rgb(255 255 255 / 87%),
    inset 1px 1px 1px rgb(255 255 255),
    0 0 13px #00000022,
    inset 0 0 23px #ffffff69;

}

.mode-btn:hover {
        background: #0000000d;
    transform: scale(1.1);
}

.mode-btn.active {
          box-shadow:
    inset -1px -1px 1px rgb(255 255 255 / 87%),
    inset 1px 1px 1px rgb(255 255 255),
    0 0 23px #d67aff78
    ;
  background: linear-gradient(135deg,#ff4e00,#ea38ff,#5c86ff,#5ca7ff);
    color: white;
}

.betting-options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    gap: 8px;
    margin-bottom: 20px;
    width: 100%;
}

.bet-button {
    padding: clamp(12px, 3vw, 16px);
    background: var(--control-bg);
    color: var(--text-primary);
    border-radius: 32px;
    cursor: pointer;
    transition: all 0.25s ease;
    font-weight: 600;
    font-size: clamp(13px, 2.5vw, 15px);
    text-align: center;
    position: relative;
    overflow: hidden;
    min-height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
      box-shadow:
    inset -1px -1px 1px rgb(255 255 255 / 87%),
    inset 1px 1px 1px rgb(255 255 255),
    0 0 23px #00000021,
    inset 0 0 23px #00000005;
}

.bet-button:before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: left 0.3s ease;
}

.bet-button:hover:before {
    left: 100%;
}

.bet-button:hover {
    transform: scale(1.02);
}

.bet-button.selected {
      background: linear-gradient(135deg, #ff00ed, #ff00cf);
    color: white;
    animation: selectedGlow 2s infinite;
}

@keyframes selectedGlow {
    0%, 100% {
        box-shadow: 0 0 16px rgb(255 53 224);
    }

    50% {
        box-shadow: 0 0 20px rgba(0, 122, 255, 0.6);
    }
}

.action-buttons {
    display: flex;
    gap: 16px;
}

.mega-button {
    padding: 16px 32px;
    border: none;
    border-radius: 33px;
    font-size: 17px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.25s ease;
    position: relative;
    overflow: hidden;
      box-shadow:
    inset -1px -1px 1px rgb(255 255 255 / 87%),
    inset 1px 1px 1px rgb(255 255 255),
    0 0 23px #79797936,
    inset 0 0 23px #0000000a;
}

.spin-button {
    
    background: linear-gradient(180deg, #0067ff, #0089ff, #ff00c9);
    background-size: 200% 200%;
    color: white;
    animation: buttonShine 3s infinite;
    box-shadow:    inset -1px -1px 1px rgb(245 92 255 / 87%),
    inset 1px 1px 1px rgb(40 255 252);
}

@keyframes buttonShine {
    0%, 100% {
        background-position: 0% 50%;
    }

    50% {
        background-position: 100% 50%;
    }
}

.spin-button:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 8px 24px rgba(0, 122, 255, 0.4);
}

.spin-button.dimmed {
    opacity: 0.5;
    filter: brightness(0.8) saturate(0.7);
    pointer-events: none;
    transform: scale(0.98);
}

.spin-button.active {
    opacity: 1;
    filter: brightness(1) saturate(1);
    pointer-events: auto;
    transform: scale(1);
    animation: spinButtonActivate 0.25s ease;
}

@keyframes spinButtonActivate {
    0% {
        transform: scale(0.98);
        filter: brightness(0.8) saturate(0.7);
    }

    50% {
        transform: scale(1.02);
        filter: brightness(1.1) saturate(1.1);
    }

    100% {
        transform: scale(1);
        filter: brightness(1) saturate(1);
    }
}

.clear-button {
  background: linear-gradient(135deg,#ffffff,#e6e6e6,#f1f1f1);
    color: var(--text-primary);
}

.clear-button:hover {
    transform: scale(1.1);
    background: var(--control-hover);
}

.status-display {
    text-align: center;
    color: var(--text-primary);
    font-size: 15px;
    margin-top: 20px;
    padding: 16px;
    background: var(--control-bg);
    border-radius: 12px;

}

.top-status-bar {
    position: fixed;
    top: max(env(safe-area-inset-top), 20px);
    left: 50%;
    border-radius: 44px;
    transform: translateX(-50%);
    z-index: 2000;
    pointer-events: none;
}

.balance-display {
   box-shadow:
    inset 2px 5px 2px rgb(110 213 255 / 13%),
    inset -1px -1px 2px rgb(231 229 255 / 65%),
    inset 0 0 1px rgb(255 255 255),
    0 12px 4px rgba(0,0,0,0.08),
    0 1px 8px rgb(237 171 234 / 20%),
    inset 0 2px 1px rgb(255 255 255 / 57%),
    0 0 23px #00000021,
    inset 0 0 23px #00000026;
    backdrop-filter: blur(22px) saturate(1.2);
    border-radius: 44px;
    padding: 12px 24px;
    text-align: center;
    background: var(--glass-bg);
    min-width: 280px;
}

.balance-text {
    color: var(--text-primary);
    font-size: clamp(15px, 3vw, 18px);
    font-weight: 600;
    margin: 2px 0;
    letter-spacing: 0.3px;
}

.balance-text span {
    color: var(--text-secondary);
    font-weight: 700;
    transition: all 0.25s ease;
}


.explosion-effect.active {
    animation: explosion 0.5s ease-out;
}

@keyframes explosion {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
    }

    50% {
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 0.7;
    }

    100% {
        transform: translate(-50%, -50%) scale(2.5);
        opacity: 0;
    }
}

@media (max-width: 768px) {
    .main-container {
        gap: 16px;
        padding: 0 12px;
    }

    .controls-panel {
        padding: 20px 16px;
        gap: 16px;
    }

    .chip-selector, .mode-selector {
        flex-wrap: wrap;
        justify-content: center;
    }

    .mode-btn {
        padding: 10px 16px;
        font-size: 14px;
    }

    .betting-options {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
    }

    .action-buttons {
        flex-direction: column;
        gap: 12px;
    }

    .mega-button {
        padding: 14px 28px;
        font-size: 16px;
        width: 100%;
    }

    .chip-3d {
        width: 56px;
        height: 56px;
        font-size: 12px;
    }

    .status-display {
        font-size: 14px;
        padding: 12px;
    }

    .glass-display {
        width: 140px;
        height: 140px;
        bottom: -60px;
    }

    .result-number {
        font-size: 3em;
    }
}

@media (max-width: 480px) {
    .betting-options {
        grid-template-columns: 1fr;
        gap: 6px;
    }

    .chip-selector {
        gap: 8px;
    }

    .chip-3d {
        width: 48px;
        height: 48px;
        font-size: 11px;
    }

    .glass-display {
        width: 120px;
        height: 120px;
        bottom: -50px;
    }

    .result-number {
        font-size: 2.5em;
    }
}

@keyframes specialResultAnimation {
    0% {
        transform: scale(0.7) rotate(-8deg);
        opacity: 0;
    }

    50% {
        transform: scale(1.1) rotate(4deg);
        opacity: 1;
    }

    100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
}

@keyframes slideUpFade {
    0% {
        transform: translate(-50%, -50%) scale(0.9);
        opacity: 1;
    }

    70% {
        transform: translate(-50%, -70%) scale(1.1);
        opacity: 1;
    }

    100% {
        transform: translate(-50%, -100%) scale(1);
        opacity: 0;
    }
}

/* Slider Styles */
.slider-wrapper {
    position: relative;
    width: 310px;
    height: 64px;
    z-index: 2;
    transform: scale(1);
    will-change: transform;
    transition: opacity 0.5s cubic-bezier(.62,0,.4,1);
    margin: 0 auto;
    /* Prevent Safari navigation gestures */
    touch-action: pan-x;
    -webkit-touch-action: pan-x;
    overscroll-behavior-x: none;
    -webkit-overscroll-behavior-x: none;
}

.slider-wrapper.fade-out {
    opacity: 0;
    pointer-events: none;
}

.slider-wrapper.dimmed {
    opacity: 0.5;
    pointer-events: none;
}

.slider-track {
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
    box-shadow:
        inset 1px -1px 11px rgb(255 255 255 / 12%),
        inset 1px -1px 55px rgb(255 255 255 / 11%),
        1px -1px 1px rgb(243 243 243 / 62%),
        -1px 1px 1px rgb(225 225 225 / 62%),
        0 2px 18px #0000000d;
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 64px;
    background: rgb(60 60 60 / 40%);
    border-radius: 36px;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    overflow: visible;
}

.slider-inner-track {
    position: absolute;
    top: 0; left: -5px;
    height: 64px;
    border-radius: 36px;
    z-index: 1;
    transform: scale(0.9);
    transition: width 0.13s;
    pointer-events: none;
    background: linear-gradient(135deg, #007AFF, #34C759);
}

.slider-label {
    position: absolute;
    left: 88px;
    top: 0;
    height: 64px;
    line-height: 64px;
    color: #fff;
    font-size: 19px;
    font-weight: 500;
    letter-spacing: 1px;
    z-index: 2;
    opacity: 0.83;
    transition: opacity 0.2s;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 2px 10px #000b;
}

.slider-knob {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 56px;
    height: 56px;
    background: #ffffff8c;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 33px;
    font-weight: bold;
    z-index: 10;
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
    border: none;
    outline: none;
    box-shadow:
        1px -1px 1px rgb(255 255 255 / 62%),
        -1px 1px 1px rgb(255 255 255 / 62%),
        0 2px 18px #00000015;
    will-change: box-shadow, left, background;
    cursor: pointer;
    user-select: none;
    transition:
        background 0.5s cubic-bezier(.62,0,.4,1),
        box-shadow 0.5s cubic-bezier(.62,0,.4,1),
        left 0.5s cubic-bezier(.62,0,.4,1);
}

.slider-knob:active {
    background: #ebebeb5c;
    box-shadow:
        1px 1px 1px rgb(255 255 255 / 62%),
        -1px -1px 1px rgb(255 255 255 / 62%);
}

.slider-arrow-polyline {
    transition:
        stroke 0.3s cubic-bezier(.62,0,.4,1),
        stroke-width 0.3s cubic-bezier(.62,0,.4,1),
        filter 0.3s cubic-bezier(.62,0,.4,1);
}

.slider-knob.active .slider-arrow-polyline {
    stroke: #1552be;
    stroke-width: 3.2;
    filter: drop-shadow(0 0 7px #2579F7);
}

.slider-knob:not(.active) .slider-arrow-polyline {
    stroke: #2579F7;
    stroke-width: 2.6;
    filter: none;
}

/* iOS26-style Dynamic Animations */
@keyframes chipHoverPulse {
    0% {
        transform: translateY(-4px) scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }
    100% {
        transform: translateY(-6px) scale(1.08);
        box-shadow: 0 8px 30px rgba(0, 122, 255, 0.4);
    }
}

@keyframes buttonSpringPress {
    0% {
        transform: scale(1);
    }
    30% {
        transform: scale(0.95);
    }
    70% {
        transform: scale(1.02);
    }
    100% {
        transform: scale(1);
    }
}

@keyframes betButtonDynamicPress {
    0% {
        transform: scale(1) rotateZ(0deg);
        box-shadow: inset -1px -1px 1px rgb(255 255 255 / 87%), inset 1px 1px 1px rgb(255 255 255);
    }
    15% {
        transform: scale(0.96) rotateZ(-0.5deg);
        box-shadow: inset -2px -2px 3px rgba(0, 0, 0, 0.1), inset 2px 2px 3px rgba(255, 255, 255, 0.9);
    }
    30% {
        transform: scale(0.94) rotateZ(0deg);
    }
    60% {
        transform: scale(1.03) rotateZ(0.3deg);
        box-shadow: 0 0 20px rgba(0, 122, 255, 0.6), inset -1px -1px 1px rgb(255 255 255 / 87%);
    }
    100% {
        transform: scale(1) rotateZ(0deg);
        box-shadow: inset -1px -1px 1px rgb(255 255 255 / 87%), inset 1px 1px 1px rgb(255 255 255);
    }
}

@keyframes modeButtonDynamicActivate {
    0% {
        transform: scale(1);
        background: #cdcdcd96;
    }
    20% {
        transform: scale(0.92);
    }
    40% {
        transform: scale(1.05);
        background: linear-gradient(135deg,#ff4e00,#ea38ff,#5c86ff,#5ca7ff);
    }
    70% {
        transform: scale(0.98);
    }
    100% {
        transform: scale(1);
        background: linear-gradient(135deg,#ff4e00,#ea38ff,#5c86ff,#5ca7ff);
    }
}

@keyframes sliderKnobDynamicDrag {
    0% {
        transform: scale(1);
        box-shadow: 1px -1px 1px rgb(255 255 255 / 62%), -1px 1px 1px rgb(255 255 255 / 62%);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(0, 122, 255, 0.8), 1px -1px 1px rgb(255 255 255 / 62%);
    }
    100% {
        transform: scale(1.05);
        box-shadow: 1px -1px 1px rgb(255 255 255 / 62%), -1px 1px 1px rgb(255 255 255 / 62%);
    }
}

@keyframes roulletteWheelSpinDynamic {
    0% {
        transform: perspective(1200px) rotateX(15deg) rotateZ(0deg) scale(1);
        filter: brightness(1) saturate(1);
    }
    25% {
        transform: perspective(1200px) rotateX(18deg) rotateZ(90deg) scale(1.02);
        filter: brightness(1.1) saturate(1.2);
    }
    50% {
        transform: perspective(1200px) rotateX(15deg) rotateZ(180deg) scale(1);
        filter: brightness(1.2) saturate(1.4);
    }
    75% {
        transform: perspective(1200px) rotateX(12deg) rotateZ(270deg) scale(0.98);
        filter: brightness(1.1) saturate(1.2);
    }
    100% {
        transform: perspective(1200px) rotateX(15deg) rotateZ(360deg) scale(1);
        filter: brightness(1) saturate(1);
    }
}

.bet-button.dynamic-press {
    animation: betButtonDynamicPress 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.mode-btn.dynamic-activate {
    animation: modeButtonDynamicActivate 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.slider-knob.dynamic-drag {
    animation: sliderKnobDynamicDrag 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) infinite;
}

.chip-3d.dynamic-select {
    animation: buttonSpringPress 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

/* Balance Zero State Styles */
.slider-wrapper.balance-zero {
    pointer-events: auto !important;
    opacity: 0.7;
    cursor: pointer;
}

.slider-wrapper.balance-zero .slider-track {
    background: linear-gradient(135deg, rgba(255, 59, 48, 0.3), rgba(255, 149, 0, 0.3));
    border: 2px solid rgba(255, 59, 48, 0.5);
}

.slider-wrapper.balance-zero .slider-knob {
    pointer-events: none;
    background: rgba(255, 59, 48, 0.8);
    animation: balanceZeroPulse 2s ease-in-out infinite;
}

.slider-wrapper.balance-zero .slider-label {
    color: #FF3B30;
    font-weight: 700;
    animation: balanceZeroTextPulse 1.5s ease-in-out infinite alternate;
}

@keyframes balanceZeroPulse {
    0%, 100% {
        box-shadow: 0 0 10px rgba(255, 59, 48, 0.5);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 20px rgba(255, 59, 48, 0.8);
        transform: scale(1.05);
    }
}

@keyframes balanceZeroTextPulse {
    0% {
        opacity: 0.7;
        text-shadow: 0 0 5px rgba(255, 59, 48, 0.5);
    }
    100% {
        opacity: 1;
        text-shadow: 0 0 15px rgba(255, 59, 48, 0.8);
    }
}

.slider-wrapper.balance-zero-tap {
    animation: balanceZeroTapEffect 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

@keyframes balanceZeroTapEffect {
    0% {
        transform: scale(1);
        background: rgba(255, 59, 48, 0.1);
    }
    30% {
        transform: scale(0.95);
        background: rgba(255, 59, 48, 0.3);
    }
    60% {
        transform: scale(1.05);
        background: rgba(255, 59, 48, 0.2);
    }
    100% {
        transform: scale(1);
        background: rgba(255, 59, 48, 0.1);
    }
}

@media (prefers-color-scheme: dark) {
    :root {
        --bg-primary: linear-gradient(145deg, #000000, #000053);
        --bg-secondary: rgba(0, 0, 0, 0.549);
        --text-primary: #ffffff;
        --text-secondary: #ffd500;
        --particle-color: rgb(255, 174, 0);
        --glass-bg: rgba(0, 0, 0, 0.352);
        --control-bg: rgba(120, 120, 128, 0.24);
        --control-hover: rgba(0, 122, 255, 0.2);
        --shadow-light: rgba(0, 0, 0, 0.3);
        --shadow-medium: rgba(0, 0, 0, 0.4);
        
    }
    .clear-button {
  background: linear-gradient(185deg,#200036,#000000);
    color: var(--text-primary);
}
}
  </style>
  <!--
  ========================================
  🔥 NOTO爆風ルーレット - ゲームルール
  ========================================
  
  【基本概念】
  18個のスロット（1-17 + 💎JACKPOT）を持つ高速回転ルーレット
  3Dプリンターチップ（100円、500円、1000円）を使用した本格カジノ体験
  
  【ゲームモード】
  🎯 ノーマルモード: 基本ゲーム、低リスク
  ⚡ エクストリームモード: 賭け金5倍、高配当
  💎 ジャックポットモード: 賭け金10倍、最大50倍配当
  
  【チップシステム】
  🪙 100円チップ: 青色、基本賭け単位
  🪙 500円チップ: 赤色、中級者向け
  🪙 1000円チップ: 金色、ハイローラー向け
  
  【賭け方と配当】
  
  1️⃣ 数字範囲賭け
  ・1-5: 3倍配当
  ・6-10: 3倍配当  
  ・11-15: 3倍配当
  ・16-17: 5倍配当（確率低）
  
  2️⃣ 色賭け（2倍配当）
  ・🔴 RED: 1,3,5,7,9,11,13,15,17（奇数）
  ・⚫ BLACK: 2,4,6,8,10,12,14,16（偶数）
  
  3️⃣ 特殊賭け（2倍配当）
  ・LOW: 1-8（低い数字）
  ・MID: 9-13（中間の数字）
  ・HIGH: 14-17（高い数字）
  
  4️⃣ 💎 JACKPOT賭け
  ・配当: 50倍（超高配当）
  ・確率: 1/18（約5.6%）
  
  【特殊演出】
  🌟 通常当選: 光の演出
  💥 JACKPOT: 爆発エフェクト + 画面全体発光
  📱 iOS振動: 賭け/スピン/結果で異なるパターン
  
  【操作方法】
  1. モードを選択（ノーマル/エクストリーム/ジャックポット）
  2. チップを選択（100/500/1000円）
  3. 賭けたい場所をタップ（複数選択可能）
  4. 🚀 SPINボタンでゲーム開始
  5. 結果発表と配当計算
  6. CLEARで賭けリセット
  
  【戦略のヒント】
  💡 範囲賭け: 安定した勝率を狙う
  💡 色賭け: 約50%の勝率、堅実
  💡 JACKPOT: 一攫千金、ハイリスクハイリターン
  💡 複数賭け: リスク分散で安定収益
  
  【注意事項】
  ⚠️ ギャンブルは適度に楽しみましょう
  ⚠️ 予算を決めて遊びましょう
  ⚠️ 勝ち逃げも大切な戦略です
  
  ========================================
  -->
</head>
<body>
  <div class="bg-particles" id="particles"></div>
  
  
  <!-- 上部残高・賭け金表示 -->
  <div class="top-status-bar">
    <div class="balance-display">
      <div class="balance-text">賭けるお金：<span id="topBetAmount">0</span></div>
      <div class="balance-text">残高：<span id="topBalance">1919</span></div>
    </div>
  </div>
  
  <div class="main-container">
    
    <div class="roulette-mega-container">
      <div class="roulette-area" id="rouletteArea">
        <div class="roulette-wheel" id="wheel">
          <div class="explosion-effect" id="explosionEffect"></div>
        </div>
      </div>
      
      <div class="glass-display">
        <div class="result-number" id="resultNumber">?</div>
      </div>
    </div>
    
    <div class="controls-panel">
      <div class="chip-selector">
        <div class="chip-selector-label">🪙 チップ選択:</div>
        <div class="chip-3d chip-100 selected" data-value="100">¥100</div>
        <div class="chip-3d chip-500" data-value="500">¥500</div>
        <div class="chip-3d chip-1000" data-value="1000">¥1000</div>
      </div>
      
      <div class="mode-selector">
        <div class="mode-btn active" data-mode="normal">ノーマル</div>
        <div class="mode-btn" data-mode="extreme">エクストリーム</div>
        <div class="mode-btn" data-mode="jackpot">ジャックポット</div>
      </div>
      
      <div class="betting-options">
        <div class="bet-button" data-bet="red">🔴 RED</div>
        <div class="bet-button" data-bet="black">⚫ BLACK</div>
        <div class="bet-button" data-bet="low">LOW (1-8)</div>
        <div class="bet-button" data-bet="mid">MID (9-13)</div>
        <div class="bet-button" data-bet="high">HIGH (14-17)</div>
        <div class="bet-button" data-bet="jackpot">💎 JACKPOT</div>
      </div>
      
      <div class="action-buttons">
        <div class="slider-wrapper" id="sliderWrapper">
          <div class="slider-track">
            <div class="slider-inner-track" id="sliderInner"></div>
            <div class="slider-label" id="sliderLabel">スライドでSpin</div>
          </div>
          <div class="slider-knob" id="sliderKnob">
            <svg id="knobSVG" width="32" height="32" viewBox="0 0 32 32">
              <polyline 
                class="slider-arrow-polyline"
                points="12,8 20,16 12,24" 
                fill="none" 
                stroke="#2579F7" 
                stroke-width="2.6"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </div>
        </div>
        <button class="mega-button clear-button" id="clearButton">CLEAR</button>
      </div>
      
      <div class="status-display" id="statusDisplay">
        賭け: ¥0 | 残高: ¥1000 | 前回: -
      </div>
    </div>
  </div>

  <!-- 音声ファイル -->
  <audio id="bgmAudio" loop preload="auto">
    <source src="Home_Ambient.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsEI3nI8N2QQAoUXrTp66hVFApGn+DoumggBjuL0vLNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DoumghBTuL0vLNeSsFJHfH8P///" type="audio/wav">
  </audio>
  <audio id="successAudio" preload="auto">
    <source src="3rdParty_Success_Haptic.m4a" type="audio/aac">
    <source src="3rdParty_Success_Haptic.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="retryAudio" preload="auto">
    <source src="3rdParty_Retry_Haptic.m4a" type="audio/aac">
    <source src="3rdParty_Retry_Haptic.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="failAudio" preload="auto">
    <source src="AuthenticationNoMatch.m4a" type="audio/aac">
    <source src="AuthenticationNoMatch.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="keyPressAudio" preload="auto">
    <source src="key_press_modifier.m4a" type="audio/aac">
    <source src="key_press_modifier.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="clearAudio" preload="auto">
    <source src="CopresenceHUDHighlight.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="specialAudio" preload="auto">
    <source src="3outAug.m4a" type="audio/aac">
    <source src="3outAug.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="jackpotAudio" preload="auto">
    <source src="3outAug.m4a" type="audio/aac">
    <source src="3outAug.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="winAudio" preload="auto">
    <source src="OpticIDUnlockMatch_Full.m4a" type="audio/aac">
    <source src="OpticIDUnlockMatch_Full.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="loseAudio" preload="auto">
    <source src="AuthenticationNoMatch.m4a" type="audio/aac">
    <source src="AuthenticationNoMatch.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="lowPowerAudio" preload="auto">
    <source src="low_power.m4a" type="audio/aac">
    <source src="low_power.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>
  <audio id="tockAudio" preload="auto">
    <source src="tock.mp3" type="audio/mpeg">
    <source src="tock.wav" type="audio/wav">
    <source src="data:audio/wav;base64,UklGRvIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0Ye4AAAAQNw==" type="audio/wav">
  </audio>

  <script type="module">
    // Prevent Safari navigation gestures
    document.addEventListener('touchstart', function(e) {
      // Prevent navigation when swiping from edges
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const x = touch.clientX;
        const windowWidth = window.innerWidth;
        
        // If touch starts within 20px of either edge, prevent default
        if (x < 20 || x > windowWidth - 20) {
          e.preventDefault();
        }
      }
    }, { passive: false });
    
    document.addEventListener('touchmove', function(e) {
      // Prevent horizontal scrolling on body
      if (e.target === document.body) {
        e.preventDefault();
      }
    }, { passive: false });
    
    // Prevent back gesture on the entire page
    let startX = null;
    document.addEventListener('touchstart', function(e) {
      startX = e.touches[0].clientX;
    });
    
    document.addEventListener('touchmove', function(e) {
      if (startX !== null) {
        const currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;
        
        // If swiping right from left edge, prevent it
        if (startX < 50 && deltaX > 0) {
          e.preventDefault();
        }
      }
    }, { passive: false });
    
    // Import modules for device detection and haptics
    let detectOS, haptic;
    let isIOS = false;
    
    try {
      const deviceModule = await import("https://esm.sh/is-device");
      detectOS = deviceModule.detectOS;
      isIOS = detectOS() === "ios";
    } catch (error) {
      console.log('Device detection failed, using fallback');
      // Fallback detection
      if (/iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) {
        isIOS = true;
      }
    }
    
    // Show warning for non-iOS devices
    if (!isIOS) {
      const warningEl = document.createElement("div");
      warningEl.className = "warning";
      warningEl.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 59, 48, 0.9);
        color: white;
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 600;
        z-index: 9999;
        backdrop-filter: blur(20px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      `;
      warningEl.textContent = "この機能はiOSデバイスで最適化されています";
      document.body.prepend(warningEl);
      
      // Hide warning after 5 seconds
      setTimeout(() => {
        if (warningEl.parentNode) {
          warningEl.style.opacity = '0';
          warningEl.style.transition = 'opacity 1s ease';
          setTimeout(() => warningEl.remove(), 1000);
        }
      }, 5000);
    }
    
    try {
      const hapticModule = await import("https://esm.sh/ios-haptics");
      haptic = hapticModule.haptic;
      console.log('iOS haptics loaded successfully');
    } catch (error) {
      console.log('iOS haptics library failed to load, using enhanced fallback');
      
      // Enhanced fallback haptic implementation
      haptic = function(type = 'light') {
        if (isIOS && window.navigator && window.navigator.vibrate) {
          // iOS-specific vibration patterns
          switch(type) {
            case 'light': navigator.vibrate(10); break;
            case 'medium': navigator.vibrate(30); break;
            case 'heavy': navigator.vibrate(50); break;
            default: navigator.vibrate(20);
          }
        } else if (navigator.vibrate) {
          navigator.vibrate(20);
        }
      };
      
      haptic.light = () => haptic('light');
      haptic.medium = () => haptic('medium');
      haptic.heavy = () => haptic('heavy');
      
      haptic.confirm = () => {
        if (isIOS) {
          navigator.vibrate([10, 50, 20]);
        } else if (navigator.vibrate) {
          navigator.vibrate([50, 50, 50]);
        }
      };
      
      haptic.error = () => {
        if (isIOS) {
          navigator.vibrate([30, 100, 30, 100, 30]);
        } else if (navigator.vibrate) {
          navigator.vibrate([100, 50, 100]);
        }
      };
      
      haptic.success = () => {
        if (isIOS) {
          navigator.vibrate([10, 30, 10, 30]);
        } else if (navigator.vibrate) {
          navigator.vibrate([50, 30, 50]);
        }
      };
      
      haptic.error = () => {
        if (isIOS) {
          navigator.vibrate([100, 50, 100, 50, 100]);
        } else if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200]);
        }
      };
      
      // 追加のhapticメソッド
      haptic.selection = () => {
        if (isIOS) {
          navigator.vibrate(10);
        } else if (navigator.vibrate) {
          navigator.vibrate(20);
        }
      };
      
      haptic.impact = () => {
        if (isIOS) {
          navigator.vibrate(30);
        } else if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      };
    }
    
    // 音声管理
    const audioManager = {
      bgm: document.getElementById('bgmAudio'),
      success: document.getElementById('successAudio'),
      retry: document.getElementById('retryAudio'),
      fail: document.getElementById('failAudio'),
      keyPress: document.getElementById('keyPressAudio'),
      clear: document.getElementById('clearAudio'),
      special: document.getElementById('specialAudio'),
      jackpot: document.getElementById('jackpotAudio'),
      win: document.getElementById('winAudio'),
      lose: document.getElementById('loseAudio'),
      lowPower: document.getElementById('lowPowerAudio'),
      tock: document.getElementById('tockAudio'),
      
      play(type) {
        try {
          if (this[type]) {
            this[type].currentTime = 0;
            this[type].volume = 1.0;
            this[type].play().catch(error => {
              console.log(`Audio play failed for ${type}:`, error);
            });
          }
        } catch (e) {
          console.log('Audio error:', e);
        }
      },
      
      startBGM() {
        try {
          if (this.bgm) {
            this.bgm.loop = true;
            this.bgm.volume = 0.3;
            this.bgm.play().catch(e => {
              // Silent fail for BGM
            });
          }
        } catch (e) {
          // Silent fail
        }
      },
      
      stopBGM() {
        try {
          if (this.bgm && !this.bgm.paused) {
            this.bgm.pause();
          }
        } catch (e) {
          // Silent fail
        }
      },
      
      // 全ての音声ファイルをテスト
      testAllAudio() {
        const audioTypes = ['bgm', 'success', 'retry', 'fail', 'keyPress', 'clear', 'special', 'jackpot', 'win', 'lose', 'lowPower', 'tock'];
        audioTypes.forEach(type => {
          if (this[type]) {
            this[type].volume = 0.1;
            this[type].play().then(() => {
              this[type].pause();
              this[type].currentTime = 0;
            }).catch(e => console.log(`${type} failed:`, e));
          }
        });
      }
    };
    
    // Enhanced haptic patterns for iOS 26
    const hapticPatterns = {
      basic: () => {
        try { 
          (haptic.light || haptic.selection || haptic)(); 
        } catch { 
          navigator.vibrate?.(10); 
        }
      },
      confirm: () => {
        try { 
          (haptic.confirm || haptic.medium || haptic.impact || haptic)(); 
        } catch { 
          navigator.vibrate?.(30); 
        }
      },
      error: () => {
        try {
          if (haptic.error) {
            haptic.error();
          } else {
            [0, 100, 200, 350, 450, 550].forEach(delay => {
              setTimeout(() => {
                try { 
                  (haptic.heavy || haptic)(); 
                } catch { 
                  navigator.vibrate?.(50); 
                }
              }, delay);
            });
          }
        } catch {
          navigator.vibrate?.([100, 50, 100, 50, 100]);
        }
      },
      
      rapidBurst: () => {
        const sequence = isIOS ? [0, 40, 80, 150, 190, 230, 300, 340, 380] : [0, 45, 90, 135, 180, 225, 270, 315, 360];
        sequence.forEach(delay => setTimeout(() => {
          try { (haptic.medium || haptic)(); } catch { navigator.vibrate?.(20); }
        }, delay));
      },
      ultraBurst: () => {
        [0, 25, 50, 75, 100].forEach(delay => setTimeout(() => {
          try { (haptic.light || haptic)(); } catch { navigator.vibrate?.(15); }
        }, delay));
      },
      staggered: () => {
        try { (haptic.heavy || haptic)(); } catch { navigator.vibrate?.(50); }
        setTimeout(() => {
          [0, 35, 70, 105, 140, 175].forEach(delay => setTimeout(() => {
            try { (haptic.light || haptic)(); } catch { navigator.vibrate?.(10); }
          }, delay));
        }, 800);
      },
      jackpot: () => {
        try { (haptic.success || haptic.confirm || haptic)(); } catch { navigator.vibrate?.(30); }
        setTimeout(() => {
          [0, 20, 40, 60, 80, 100, 120, 140].forEach(delay => setTimeout(() => {
            try { (haptic.heavy || haptic)(); } catch { navigator.vibrate?.(40); }
          }, delay));
        }, 150);
        setTimeout(() => {
          [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].forEach(delay => setTimeout(() => {
            try { (haptic.light || haptic)(); } catch { navigator.vibrate?.(10); }
          }, delay));
        }, 400);
      },
      spinning: () => {
        [0, 60, 120].forEach(delay => setTimeout(() => {
          try { (haptic.medium || haptic)(); } catch { navigator.vibrate?.(25); }
        }, delay));
      }
    };
    
    // パーティクル生成
    function createParticles() {
      const container = document.getElementById('particles');
      setInterval(() => {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 2 + 's';
        particle.style.animationDuration = (4 + Math.random() * 4) + 's';
        container.appendChild(particle);
        
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 8000);
      }, 300);
    }
    
    // ルーレット番号設定
    const NUMBERS = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,'💎'];
    const BALL_RADIUS = 220;
    const BALL_R = 16;
    
    // DOM要素
    const wheel = document.getElementById('wheel');
    const rouletteArea = document.getElementById('rouletteArea');
    const resultNumber = document.getElementById('resultNumber');
    let ball = null; // ボールは動的に作成
    const clearButton = document.getElementById('clearButton');
    const statusDisplay = document.getElementById('statusDisplay');
    const explosionEffect = document.getElementById('explosionEffect');
    
    // ゲーム状態
    let gameState = {
      balance: 1919, // 初期残高を1919円に変更
      totalBet: 0,
      currentBetType: null, // 現在選択されている賭けタイプ（単一選択）
      isSpinning: false,
      ballMoving: false, // ボールが動いているかどうか
      currentAngle: 0,
      baseSpeed: 0.3,
      mode: 'normal',
      lastResult: null,
      lastResultIndex: null, // 前回結果のインデックス
      selectedChipValue: 100, // 選択されたチップ価値
      hasBets: false, // 賭けがあるかどうか
      swipeEnabled: false, // スワイプが有効かどうか
      continuousPlay: false, // 連続プレイモード
      gameEnded: false // ゲーム終了フラグ
    };
    
    // 数字をホイールに配置
    function setupWheel() {
      const wheelSize = wheel.offsetWidth || 460; // ホイールの実際のサイズを取得
      const centerX = wheelSize / 2;
      const centerY = wheelSize / 2;
      const radius = wheelSize * 0.35; // ホイールサイズの35%の半径で配置
      
      for(let i = 0; i < NUMBERS.length; i++) {
        // 18個の要素を均等に配置（360度 ÷ 18 = 20度間隔）
        const angle = i * (360 / NUMBERS.length);
        const rad = (angle - 90) * Math.PI / 180; // -90度で12時方向から開始
        
        // 円周上の座標を計算
        const x = centerX + radius * Math.cos(rad);
        const y = centerY + radius * Math.sin(rad);
        
        const numberLabel = document.createElement('div');
        numberLabel.className = 'number-label';
        
        const numberText = document.createElement('div');
        numberText.className = 'number-text';
        numberText.textContent = NUMBERS[i];
        numberText.style.left = x + 'px';
        numberText.style.top = y + 'px';
        numberText.style.transform = 'translate(-50%, -50%)'; // 回転は削除、テキストを中央配置のみ
        numberText.dataset.index = i;
        
        numberLabel.appendChild(numberText);
        wheel.appendChild(numberLabel);
      }
      
      // ボールを作成してルーレット内に配置
      createBall();
    }
    
    // 前回結果の表示を更新
    function updateLastResultDisplay() {
      // すべての数字から前回結果クラスを削除
      document.querySelectorAll('.number-text').forEach(el => {
        el.classList.remove('last-result');
      });
      
      // 前回結果がある場合、該当する数字に青い影を追加
      if (gameState.lastResultIndex !== null) {
        const numberTexts = document.querySelectorAll('.number-text');
        if (numberTexts[gameState.lastResultIndex]) {
          numberTexts[gameState.lastResultIndex].classList.add('last-result');
        }
      }
    }
    
    // ホイール回転
    function updateWheel(angle) {
      wheel.style.transform = `perspective(1200px) rotateX(15deg) rotateZ(${angle}deg)`;
    }
    
    // ボールを作成
    function createBall() {
      if (ball) {
        ball.remove();
      }
      ball = document.createElement('div');
      ball.className = 'ball';
      ball.id = 'ball';
      wheel.appendChild(ball);
      setBallPosition(0); // 初期位置を設定
    }
    
    // ボール位置設定 - 数字の位置の少し内側に配置
    function setBallPosition(numberIndex) {
      if (!ball || numberIndex < 0 || numberIndex >= NUMBERS.length) return;
      
      const wheelSize = wheel.offsetWidth || 460;
      const centerX = wheelSize / 2;
      const centerY = wheelSize / 2;
      const radius = wheelSize * 0.25; // 数字より内側に配置（25%の半径）
      
      // 各数字/ダイヤの角度を計算
      const angle = (numberIndex * (360/NUMBERS.length)) % 360;
      const rad = (angle - 90) * Math.PI / 180;
      
      const x = centerX + radius * Math.cos(rad) - 10; // ボールサイズの半分
      const y = centerY + radius * Math.sin(rad) - 10; // ボールサイズの半分
      
      ball.style.left = `${x}px`;
      ball.style.top = `${y}px`;
    }
    
    // 結果番号取得
    function getResultFromAngle(deg) {
      const sector = Math.floor(((deg + 180 + (360/NUMBERS.length)/2) % 360) / (360/NUMBERS.length));
      return NUMBERS[sector];
    }
    
    // チップ選択
    document.querySelectorAll('.chip-3d').forEach(chip => {
      chip.addEventListener('click', () => {
        if (gameState.isSpinning) return;
        
        // ゲーム終了フラグをリセット
        gameState.gameEnded = false;
        
        // 動的アニメーション追加
        chip.classList.add('dynamic-select');
        setTimeout(() => chip.classList.remove('dynamic-select'), 400);
        
        document.querySelectorAll('.chip-3d').forEach(c => c.classList.remove('selected'));
        chip.classList.add('selected');
        gameState.selectedChipValue = parseInt(chip.dataset.value);
        
        // チップ選択時の振動と音
        hapticPatterns.basic();
        audioManager.play('tock');
        updateStatus();
        updateTopStatus();
      });
    });
    
    // モード切り替え
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gameState.isSpinning) return;
        
        // ゲーム終了フラグをリセット
        gameState.gameEnded = false;
        
        // 動的アニメーション追加
        btn.classList.add('dynamic-activate');
        setTimeout(() => btn.classList.remove('dynamic-activate'), 600);
        
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameState.mode = btn.dataset.mode;
        
        // モード切り替え時の振動と音
        hapticPatterns.confirm();
        audioManager.play('tock');
      });
    });
    
    // 賭けボタン（単一選択）
    document.querySelectorAll('.bet-button').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gameState.isSpinning) return;
        
        // ゲーム終了フラグをリセット（確実に賭けができるように）
        gameState.gameEnded = false;
        
        // 動的アニメーション追加
        btn.classList.add('dynamic-press');
        setTimeout(() => btn.classList.remove('dynamic-press'), 500);
        
        const betType = btn.dataset.bet;
        const betAmount = gameState.selectedChipValue;
        
        if (gameState.balance >= betAmount) {
          // 以前の選択をクリア
          if (gameState.currentBetType) {
            gameState.balance += gameState.totalBet; // 前の賭け金を戻す
          }
          
          // すべてのボタンから選択状態を削除
          document.querySelectorAll('.bet-button').forEach(b => b.classList.remove('selected'));
          
          // 新しい賭けを設定
          gameState.currentBetType = betType;
          gameState.totalBet = betAmount;
          gameState.balance -= betAmount;
          gameState.hasBets = true;
          gameState.swipeEnabled = true;
          
          btn.classList.add('selected');
          
          // スライダーをアクティブに
          sliderWrapper.classList.remove('dimmed', 'balance-zero');
          
          // 賭け成功時の振動と音
          hapticPatterns.basic();
          audioManager.play('tock');
          updateStatus();
          updateTopStatus();
        } else {
          // 残高不足時の振動と音
          hapticPatterns.error();
          audioManager.play('lowPower'); // 残高不足時はlow_power音に変更
        }
      });
    });
    
    // 賭け金額取得
    function getBetAmount() {
      switch(gameState.mode) {
        case 'extreme': return 50;
        case 'jackpot': return 100;
        default: return 10;
      }
    }
    
    // 高速5回hapticパターン - iOS26最適化
    hapticPatterns.rapidFive = () => {
      if (isIOS) {
        const delays = [0, 25, 50, 75, 100];
        delays.forEach(delay => {
          setTimeout(() => {
            if (haptic.medium) {
              haptic.medium();
            } else {
              haptic();
            }
          }, delay);
        });
      } else {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            if (haptic.heavy) {
              haptic.heavy();
            } else {
              haptic();
            }
          }, i * 30);
        }
      }
    };
    
    // スライダー要素の取得
    const sliderWrapper = document.getElementById('sliderWrapper');
    const sliderKnob = document.getElementById('sliderKnob');
    const sliderInner = document.getElementById('sliderInner');
    const sliderLabel = document.getElementById('sliderLabel');
    const knobSVG = document.getElementById('knobSVG');
    
    // スライダー状態管理
    let sliderState = {
      isDragging: false,
      startX: 0,
      knobX: 0,
      lastX: 0,
      knobWidth: 56,
      wrapperWidth: 310,
      maxOffset: 250 // 310 - 56 - 4
    };
    
    // スライダー位置設定
    function setSliderKnobPos(x) {
      sliderKnob.style.left = `${x + 4}px`;
      sliderInner.style.width = `${72 + x}px`;
      sliderLabel.style.opacity = `${1 - x / sliderState.maxOffset}`;
    }
    
    // スライダーアクティブ状態設定
    function setSliderActive(val) {
      if(val) sliderKnob.classList.add("active");
      else sliderKnob.classList.remove("active");
    }
    
    // スライダードラッグ開始
    function startSliderDrag(clientX) {
      // 残高が0の場合は特別処理
      if (gameState.balance <= 0) {
        handleBalanceZeroTap();
        return;
      }
      
      // 灰色（dimmed）状態の場合は特別処理
      if (sliderWrapper.classList.contains('dimmed')) {
        handleDimmedSliderTap();
        return;
      }
      
      if (gameState.totalBet === 0 || !gameState.currentBetType) {
        // 賭けがない場合はエラー音
        hapticPatterns.error();
        audioManager.play('retry');
        return;
      }
      
      const nowLeft = parseFloat(sliderKnob.style.left) || 4;
      if (nowLeft > 14) return;
      
      sliderState.isDragging = true;
      sliderState.startX = clientX;
      sliderState.knobX = 0;
      sliderState.lastX = 0;
      
      sliderKnob.style.transition = "none";
      sliderInner.style.transition = "none";
      setSliderActive(true);
      
      // 動的アニメーション追加
      sliderKnob.classList.add('dynamic-drag');
      
      hapticPatterns.basic();
      requestAnimationFrame(updateSliderKnob);
    }
    
    // 残高0時のタップ処理
    function handleBalanceZeroTap() {
      // iOS haptic.error パターン
      if (isIOS && haptic.error) {
        haptic.error();
      } else {
        hapticPatterns.error();
      }
      
      // low_power音を再生
      audioManager.play('lowPower');
      
      // タップエフェクトアニメーション
      sliderWrapper.classList.add('balance-zero-tap');
      setTimeout(() => sliderWrapper.classList.remove('balance-zero-tap'), 600);
      
      // 残高を少し追加（緊急時）
      setTimeout(() => {
        gameState.balance += 100;
        updateBalanceZeroState();
        updateStatus();
        updateTopStatus();
      }, 1000);
    }
    
    // スライダーノブ更新
    function updateSliderKnob() {
      if (!sliderState.isDragging) return;
      setSliderKnobPos(sliderState.knobX);
      requestAnimationFrame(updateSliderKnob);
    }
    
    // スライダー完了処理
    function onSlideComplete() {
      // スピン実行
      hapticPatterns.rapidFive();
      
      // コントロールパネルをスライドダウン
      const controlsPanel = document.querySelector('.controls-panel');
      controlsPanel.classList.add('slide-down');
      controlsPanel.classList.remove('slide-up', 'fade-in');
      
      // BGMを一時的に音量下げる（完全停止しない）
      if (audioManager.bgm && !audioManager.bgm.paused) {
        audioManager.bgm.volume = 0.1;
      }
      
      spin();
    }
    
    // スライダー失敗処理
    function onSlideFail() {
      hapticPatterns.error();
      
      sliderKnob.style.transition = "left 0.5s cubic-bezier(.62,0,.4,1)";
      sliderKnob.style.left = "4px";
      sliderState.knobX = 0;
      sliderInner.style.transition = "width 0.13s";
      sliderInner.style.width = "72px";
      sliderLabel.style.transition = "opacity 0.2s";
      sliderLabel.style.opacity = 1;
    }
    
    // 残高ゼロ状態の管理
    function updateBalanceZeroState() {
      if (gameState.balance <= 0) {
        sliderWrapper.classList.add('balance-zero');
        sliderWrapper.classList.remove('dimmed');
        sliderLabel.textContent = '残高補充 - タップ';
      } else {
        sliderWrapper.classList.remove('balance-zero');
        sliderLabel.textContent = 'スライドでSpin';
      }
    }
    
    // スライダードラッグ終了
    function endSliderDrag() {
      if (!sliderState.isDragging) return;
      
      sliderState.isDragging = false;
      setSliderActive(false);
      
      // 動的アニメーション停止
      sliderKnob.classList.remove('dynamic-drag');
      
      hapticPatterns.basic();
      
      if (sliderState.knobX >= sliderState.maxOffset * 0.9) {
        onSlideComplete();
      } else {
        onSlideFail();
      }
    }
    
    // スライダーイベントリスナー
    sliderKnob.addEventListener("touchstart", e => {
      e.preventDefault();
      e.stopPropagation();
      if (e.touches && e.touches.length > 0) startSliderDrag(e.touches[0].clientX);
    }, { passive: false });
    
    sliderKnob.addEventListener("mousedown", e => {
      e.preventDefault();
      startSliderDrag(e.clientX);
      document.body.style.userSelect = "none";
    });
    
    sliderWrapper.addEventListener("touchmove", e => {
      // Prevent default to block Safari navigation
      e.preventDefault();
      e.stopPropagation();
      
      if (!sliderState.isDragging) return;
      const clientX = e.touches[0].clientX;
      let dx = clientX - sliderState.startX;
      if (dx < 0) dx = 0;
      sliderState.knobX = Math.max(0, Math.min(dx, sliderState.maxOffset));
      if (Math.abs(sliderState.knobX - sliderState.lastX) > 2) {
        hapticPatterns.basic();
        sliderState.lastX = sliderState.knobX;
      }
    }, { passive: false });
    
    window.addEventListener("mousemove", e => {
      if (!sliderState.isDragging) return;
      let dx = e.clientX - sliderState.startX;
      if (dx < 0) dx = 0;
      sliderState.knobX = Math.max(0, Math.min(dx, sliderState.maxOffset));
    });
    
    sliderWrapper.addEventListener("touchend", (e) => {
      e.preventDefault();
      endSliderDrag();
    }, { passive: false });
    window.addEventListener("mouseup", endSliderDrag);
    sliderWrapper.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      endSliderDrag();
    }, { passive: false });
    
    // スライダータップ機能（灰色状態 + 残高ゼロ状態）
    sliderWrapper.addEventListener("click", (e) => {
      e.stopPropagation();
      
      // 残高ゼロ時の特別処理
      if (gameState.balance <= 0 && sliderWrapper.classList.contains('balance-zero')) {
        handleBalanceZeroTap();
        return;
      }
      
      // 灰色（dimmed）状態でのタップ処理
      if (sliderWrapper.classList.contains('dimmed')) {
        handleDimmedSliderTap();
        return;
      }
    });
    
    // 灰色スライダータップ処理
    function handleDimmedSliderTap() {
      // iOS haptic.error パターン
      if (isIOS && haptic.error) {
        haptic.error();
      } else {
        hapticPatterns.error();
      }
      
      // low_power音を再生
      audioManager.play('lowPower');
      
      // タップエフェクトアニメーション
      sliderWrapper.classList.add('balance-zero-tap');
      setTimeout(() => sliderWrapper.classList.remove('balance-zero-tap'), 600);
    };
    
    // クリアボタン
    clearButton.addEventListener('click', () => {
      // 常にクリア可能に変更
      // クリア時の振動と音
      hapticPatterns.ultraBurst();
      audioManager.play('clear');
      
      // 音が終わったらページを再読み込み
      setTimeout(() => {
        location.reload();
      }, 2000);
    });
    
    // 賭けクリア
    function clearBets() {
      gameState.balance += gameState.totalBet;
      gameState.totalBet = 0;
      gameState.currentBetType = null;
      gameState.hasBets = false;
      gameState.swipeEnabled = false;
      
      document.querySelectorAll('.bet-button').forEach(btn => {
        btn.classList.remove('selected');
      });
      
      // スライダーを薄くする
      sliderWrapper.classList.add('dimmed');
      
      // スライダーをリセット
      sliderKnob.style.transition = "left 0.5s cubic-bezier(.62,0,.4,1)";
      sliderKnob.style.left = "4px";
      sliderState.knobX = 0;
      sliderInner.style.transition = "width 0.13s";
      sliderInner.style.width = "72px";
      sliderLabel.style.transition = "opacity 0.2s";
      sliderLabel.style.opacity = 1;
      
      updateStatus();
      updateTopStatus();
    }
    
    // スピン実行
    function spin() {
      gameState.isSpinning = true;
      gameState.ballMoving = true; // ボール移動開始
      resultNumber.classList.add('blur');
      
      // 結果決定
      const resultIndex = Math.floor(Math.random() * NUMBERS.length);
      const result = NUMBERS[resultIndex];
      
      // 高速回転
      const spins = 8 + Math.random() * 5;
      const finalAngle = (360 / NUMBERS.length) * resultIndex;
      const totalRotation = spins * 360 + finalAngle;
      
      animateSpinSequence(totalRotation, result, resultIndex);
    }
    
    // スピンアニメーション - ボールが1→2→...17→ダイヤの順番で移動
    function animateSpinSequence(totalRotation, result, resultIndex) {
      const startTime = performance.now();
      const duration = 4000;
      let currentBallIndex = 0; // 1からスタート
      let lastMoveTime = startTime;
      const initialMoveInterval = 150; // 初期の遅い速度
      const finalMoveInterval = 50; // 最終的な速い速度
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // ルーレットの回転（時計回り）
        const eased = 1 - Math.pow(1 - progress, 3);
        const currentAngle = gameState.currentAngle + totalRotation * eased;
        updateWheel(currentAngle);
        
        // ボールの移動速度を時間とともに上げる
        const moveInterval = initialMoveInterval - (initialMoveInterval - finalMoveInterval) * progress;
        
        // ボールの移動（1→2→...の順番）
        if (currentTime - lastMoveTime >= moveInterval) {
          // ボールを次の数字に移動（1→2→...の順番）
          currentBallIndex = (currentBallIndex + 1) % NUMBERS.length;
          setBallPosition(currentBallIndex);
          lastMoveTime = currentTime;
        }
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // 最終結果の位置にボールを配置
          setBallPosition(resultIndex);
          finishSpin(result, currentAngle, resultIndex);
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    // スピン終了
    function finishSpin(result, finalAngle, resultIndex) {
      gameState.currentAngle = finalAngle % 360;
      
      // ボールを最終結果の数字の位置に確実に配置
      setBallPosition(resultIndex);
      
      // 爆発エフェクト
      if (result === '💎') {
        explosionEffect.classList.add('active');
        setTimeout(() => explosionEffect.classList.remove('active'), 600);
      }
      
      setTimeout(() => {
        // ガラスディスプレイに最終結果を表示
        resultNumber.textContent = result;
        resultNumber.classList.remove('blur');
        
        // 配当計算
        const winnings = calculateWinnings(result);
        
        // 前回結果を更新
        gameState.lastResult = result;
        gameState.lastResultIndex = resultIndex;
        updateLastResultDisplay();
        
        // 結果に応じた振動と音声と演出
        if (result === '💎') {
          // ダイヤモンド: 3outAug.m4a
          hapticPatterns.jackpot();
          audioManager.play('jackpot');
          showSpecialAnimation(result, winnings);
        } else if (winnings > 0) {
          // お金が増った: OpticIDUnlockMatch_Full.m4a
          if (result === 16 || result === 17) {
            hapticPatterns.jackpot();
            showSpecialAnimation(result, winnings);
          } else if (result >= 14 && result <= 15) {
            hapticPatterns.rapidBurst();
            showWinAnimation(winnings);
          } else if (result >= 9 && result <= 13) {
            hapticPatterns.basic();
            showWinAnimation(winnings);
          } else {
            hapticPatterns.confirm();
            showWinAnimation(winnings);
          }
          audioManager.play('win');
        } else {
          // お金が減った: AuthenticationNoMatch.m4a
          if (result === 16 || result === 17) {
            hapticPatterns.jackpot();
          } else if (result >= 14 && result <= 15) {
            hapticPatterns.rapidBurst();
          } else if (result >= 9 && result <= 13) {
            hapticPatterns.basic();
          } else {
            hapticPatterns.staggered();
          }
          audioManager.play('lose');
        }
        
        // 残高更新
        gameState.balance += winnings;
        
        // 残高状態を更新
        updateBalanceZeroState();
        
        // 常に継続可能な設計 - 新しい賭けを開始
        gameState.totalBet = 0;
        gameState.currentBetType = null;
        gameState.isSpinning = false;
        gameState.ballMoving = false; // ボール移動停止
        gameState.hasBets = false;
        gameState.swipeEnabled = false;
        gameState.gameEnded = false; // ゲーム継続
        
        document.querySelectorAll('.bet-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        
        // チップ選択とモード選択を再度有効化
        document.querySelectorAll('.chip-3d').forEach(chip => {
          chip.style.pointerEvents = 'auto';
          chip.style.opacity = '1';
        });
        
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.style.pointerEvents = 'auto';
          btn.style.opacity = '1';
        });
        
        // スライダーを非アクティブにして新しい賭けを待つ
        sliderWrapper.classList.add('dimmed');
        
        // スライダーをリセット
        sliderKnob.style.transition = "left 0.5s cubic-bezier(.62,0,.4,1)";
        sliderKnob.style.left = "4px";
        sliderState.knobX = 0;
        sliderInner.style.transition = "width 0.13s";
        sliderInner.style.width = "72px";
        sliderLabel.style.transition = "opacity 0.2s";
        sliderLabel.style.opacity = 1;
        
        // ボールが停止した後にコントロールパネルをフェードインで再表示
        setTimeout(() => {
          const controlsPanel = document.querySelector('.controls-panel');
          controlsPanel.classList.remove('slide-down');
          controlsPanel.classList.add('fade-in', 'slide-up');
        }, 800); // ボールが停止した後に表示
        
        updateStatus();
        updateTopStatus();
        
        // BGM音量を元に戻す
        setTimeout(() => {
          if (audioManager.bgm && !audioManager.bgm.paused) {
            audioManager.bgm.volume = 0.3;
          } else {
            audioManager.startBGM();
          }
        }, winnings > 0 ? 2000 : 800);
        
      }, 800);
    }
    
    // 配当計算（単一選択対応）
    function calculateWinnings(result) {
      if (!gameState.currentBetType) return 0;
      
      let multiplier = 0;
      const betType = gameState.currentBetType;
      
      if (betType === `${result}`) multiplier = 17; // 直接的中
      else if (betType === 'jackpot' && result === '💎') multiplier = 50;
      else if (betType === 'red' && [1,3,5,7,9,11,13,15,17].includes(result)) multiplier = 2;
      else if (betType === 'black' && [2,4,6,8,10,12,14,16].includes(result)) multiplier = 2;
      else if (betType === 'low' && result >= 1 && result <= 8) multiplier = 2;
      else if (betType === 'mid' && result >= 9 && result <= 13) multiplier = 2;
      else if (betType === 'high' && result >= 14 && result <= 17) multiplier = 2;
      
      return gameState.totalBet * multiplier;
    }
    
    // 特殊結果のアニメーション（3秒かけて美しく表示）
    function showSpecialAnimation(result, winnings) {
      // 結果表示エリアを特別仕様に
      resultNumber.style.fontSize = '5em';
      resultNumber.style.animation = 'specialResultAnimation 3s ease-out';
      
      if (result === '💎') {
        // ジャックポット演出
        document.body.style.background = 'radial-gradient(circle, #ffd60a 0%, #ff006e 50%, #8ecae6 100%)';
        explosionEffect.classList.add('active');
        setTimeout(() => explosionEffect.classList.remove('active'), 600);
      }
      
      // 3秒後に勝利金をスライドアップ
      setTimeout(() => {
        showWinAnimation(winnings);
        document.body.style.background = 'radial-gradient(circle, #000814 0%, #001d3d 30%, #003566 70%, #000814 100%)';
        resultNumber.style.fontSize = '4em';
        resultNumber.style.animation = '';
      }, 3000);
    }
    
    // 勝利アニメーション（スライドアップ）
    function showWinAnimation(winnings) {
      if (winnings <= 0) return;
      
      const winDisplay = document.createElement('div');
      winDisplay.className = 'win-animation';
      winDisplay.textContent = `+¥${winnings.toLocaleString()}`;
      winDisplay.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3em;
        font-weight: 900;
        color: #ffd700;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        z-index: 3000;
        pointer-events: none;
        animation: slideUpFade 2s ease-out forwards;
      `;
      
      document.body.appendChild(winDisplay);
      
      setTimeout(() => {
        if (winDisplay.parentNode) {
          winDisplay.parentNode.removeChild(winDisplay);
        }
      }, 2000);
    }
    
    // 上部ステータス更新
    function updateTopStatus() {
      // リアルタイムで数値を更新してトレンド表示
      const betAmountElement = document.getElementById('topBetAmount');
      const balanceElement = document.getElementById('topBalance');
      
      // 数値の変化をアニメーション付きで表示
      betAmountElement.style.transform = 'scale(1.1)';
      betAmountElement.style.color = '#ffbe0b';
      betAmountElement.textContent = gameState.totalBet;
      
      balanceElement.style.transform = 'scale(1.1)';
      balanceElement.style.color = gameState.balance > 1000 ? '#00f5ff' : '#ff0a54';
      balanceElement.textContent = gameState.balance;
      
      // アニメーションリセット
      setTimeout(() => {
        betAmountElement.style.transform = 'scale(1)';
        betAmountElement.style.color = '#fff3cd';
        balanceElement.style.transform = 'scale(1)';
        balanceElement.style.color = '#fff3cd';
      }, 300);
    }
    
    // 状態表示更新
    function updateStatus() {
      const lastResultText = gameState.lastResult ? `${gameState.lastResult}` : '-';
      const chipText = `¥${gameState.selectedChipValue}チップ選択中`;
      statusDisplay.innerHTML = `
        <div>💰 残高: ¥${gameState.balance.toLocaleString()} | 🎯 賭け: ¥${gameState.totalBet.toLocaleString()}</div>
        <div>🪙 ${chipText} | 📊 前回: ${lastResultText}</div>
      `;
    }
    
    
    // 自動回転中のhaptic
    let lastTickNum = null;
    
    // スワイプ機能（元ファイルのスワイプ機能を再実装）
    let dragStart = null;
    let dragStartAngle = 0;
    let lastMoveTime = 0;
    let lastAngle = 0;
    let velocity = 0;
    
    rouletteArea.addEventListener('pointerdown', e => {
      if (!gameState.swipeEnabled || gameState.isSpinning) return;
      
      rouletteArea.setPointerCapture(e.pointerId);
      dragStart = { x: e.clientX, y: e.clientY };
      dragStartAngle = gameState.currentAngle;
      lastAngle = dragStartAngle;
      lastMoveTime = Date.now();
      velocity = 0;
      hapticPatterns.basic(); // スワイプ開始振動
    });
    
    rouletteArea.addEventListener('pointermove', e => {
      if (!dragStart || !gameState.swipeEnabled || gameState.isSpinning) return;
      
      const centerX = rouletteArea.offsetLeft + rouletteArea.offsetWidth / 2;
      const centerY = rouletteArea.offsetTop + rouletteArea.offsetHeight / 2;
      const angle1 = Math.atan2(dragStart.y - centerY, dragStart.x - centerX) * 180 / Math.PI;
      const angle2 = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
      
      let delta = angle2 - angle1;
      if (delta > 180) delta -= 360;
      if (delta < -180) delta += 360;
      
      gameState.currentAngle = dragStartAngle + delta;
      updateWheel(gameState.currentAngle);
      
      let now = Date.now();
      velocity = (gameState.currentAngle - lastAngle) / (now - lastMoveTime) * 19;
      lastAngle = gameState.currentAngle;
      lastMoveTime = now;
      gameState.baseSpeed = Math.max(0.3, Math.min(1.5, Math.abs(velocity)));
      
      // haptic
      let tickNum = Math.floor(((gameState.currentAngle + 180) / (360/NUMBERS.length))) % NUMBERS.length;
      if (tickNum !== lastTickNum) {
        hapticPatterns.basic();
        lastTickNum = tickNum;
      }
    });
    
    rouletteArea.addEventListener('pointerup', e => {
      if (!gameState.swipeEnabled) return;
      
      // スワイプ終了時の振動
      if (Math.abs(velocity) > 5) {
        hapticPatterns.spinning();
      }
      
      dragStart = null;
    });
    
    // 自動回転 - スピン中以外はボールを動かさない
    function autoRotate() {
      if (!gameState.isSpinning) {
        gameState.currentAngle = (gameState.currentAngle + gameState.baseSpeed) % 360;
        updateWheel(gameState.currentAngle);
        
        // スピン中ではない時はボールを初期位置に固定
        if (!gameState.ballMoving) {
          setBallPosition(0); // 数字1の位置に固定
        }
      }
      requestAnimationFrame(autoRotate);
    }
    
    // 初期化
    setupWheel(); // この中でcreateBall()が呼ばれる
    createParticles();
    updateStatus();
    updateTopStatus();
    updateWheel(0);
    
    // スライダー初期化
    updateBalanceZeroState(); // 残高状態チェック
    if (gameState.balance > 0) {
      sliderWrapper.classList.add('dimmed'); // 最初は無効状態
    }
    setSliderKnobPos(0); // 初期位置設定
    
    // 音声テスト実行
    setTimeout(() => {
      audioManager.testAllAudio();
    }, 1000);
    
    // BGMを開始
    audioManager.startBGM();
    
    // ユーザーインタラクション後にオーディオを有効化
    document.addEventListener('click', () => {
      audioManager.startBGM();
    }, { once: true });
    
    requestAnimationFrame(autoRotate);
  </script>
</body>
</html>
